# Работа с Git
## 1. Проверка наличия установленного Git
В терминале выполнить команду `git version`.

Если Git установлен появиться сообщение с информацией версии программы, инчае будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git с [сайта](https://git-scm.com/downloads).
Устанавливаем все по умоляанию.

## 3. Настройка Git

При первом использовании Git необходимо представится. Для этого необходимо ввести в терминале две команды 
```
git cinfig --global user.name "Ваше имя англ буквами"
git config --global user.email "Ваша электронная почта"
```
## 4. Инициализация репозитория

Для создания нового репозитория используется команда `git init`. Команду `git init` выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога.

## 5. Запись изменений в репозиторий

**Команда git status**

Команда `git status` показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

**Команда git add**

Команда `git add` добавляет содержимое рабочего каталога в индекс для последующего коммита. По умолчанию `git commit` использует лишь этот индекс, так что вы можете использовать `git add` для сборки слепка вашего следующего коммита. Для добавления изменения или нового файла необходимо после команды `git add` написать имя файла с расширением, как на примере:
```
git add Git_instruction.md
```
>[!Подсказка]
>Можно полнстью не писать имя файла а написать 3-4 начальых букв и нажать Tab, Git сам добавить полное название файла. 


**Команда git commit**

Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add`, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

Можно добавить комменарии к коммиту для этого необходимо в командной строке вместе с командой `commit` указав его после параметра `-m`, как в следующем примере:
```
git commit -m "Добавьте комментарии к комиту"
```
В любой момент вам может потребоваться что-либо отменить. Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр `--amend`, как вследующем примере:
```
git commit --amend
```
>[!Внимание]
>Будьте осторожны, не все операции отмены в свою очередь можно отменить! Это одна из редких областей Git, где неверными действиями можно необратимо удалить результаты своей работы.

**Команда git diff**

Команда `git diff` используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей копией и индексом (собственно `git diff`), разница между индексом и последним коммитом (`git diff --staged`), или между любыми двумя коммитами (`git diff master branchB`).

## 6. Просмотр истории коммитов

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда `git log`.

Если вы запустите команду `git log` в терминале, вы увидите следующий вывод:

![Вывод команды git log](git_log.jpg)

>По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху.

Из примера можно увидеть, что данная команда перечисляет коммиты с их SHA-1 контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита.

Команда `git log` имеет очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим одну из них.

Опция `oneline` выводит каждый коммит в одну строку, что может быть очень удобным если вы просматриваете большое количество коммитов. Для этого вводим в терминал `git log --oneline` и увидем вывод:
![Вывод команды git log --oneline](git_log_oneline.jpg)

## 7. перемещение между сохранениями (git checkout)

Когда у нас есть несколько комитов и мы хотим переключится к одному из них, чтобы это сделать нам поможет команда `git checkout`. Но для того чтобы перейти к определёному сохранёному коммиту нам потребуется использовать команду `git log` или `git log --oneline`, второй вариант для более удобного вывода если у нас было много коммитов.
![Вывод команды git log --oneline](git_log_oneline.jpg)
Далее нам придется скопировать закарашеным жёлтым цветом имя коммита (это фиксация нашего коммита), далее вводим в терминал:
```
git checkout 7a04e03
```
И мы перейдом к коммиту `7a04e03` где мы добавляли заголовки и пункт 4 и втерминале увидим такое сообщение:
![Подсказки в терминале после введёных команд](git_checkout.jpg)
Здесь терминал нам подсказывает что мы перешли на ветку `7a04e03` и ниже команды которые мы можем ввести в терминал. `git switch -c new-branch-name` с помощью которой мы сможем создать новый бранч. И команды которые помогут нам вернутся на актуалную позицию, это команды:
```
git switch -
git checkout master
```

## 8. Игнорирование файла

Для того чтобы исключить из отлеживания в репозитории определёные файлы или папки необходимо создать там файл ***.gitignore*** и записать в него их названия или шаблоныб соответсвующие такие файлам или папкам

## 9. Создание веток в Git

ВКоманда `git branch` позволяет создавать, просматривать, переименовывать и удалять ветки. Она не дает возможности переключаться между ветками или выполнять слияние разветвленной истории. Именно поэтому команда `git branch` тесно связана с командами `git checkout` и `git merge`.

По умолчанию имя основной ветки в Git - **`master`.**

Создать ветку можно командой:
```
git branch <имя новой ветки>
```
Эта команда не выполняет переключение на эту новую ветку.

Список веток в репозитории можно посмотреть с помощью команды `git branch` или с командой `git branch --list`.

Текущая ветка будет отмечена звёздочкой (*):**\*master**

## 10. Слияние веток и разрешение конфликтов
*Слияние веток*

Команда `git merge` объединяет несколько последовательностей коммитов в общую историю. Чаще всего команду `git merge` используют для объединения двух веток.
Для слияния выбраной ветки в текущей нужно выполнить команду:
```
git merge <название выбраной ветки>
```
Перед слиянием следует предпринять несколько подготовительных действий, чтобы операция прошла без проблем.

Выполните команду `git status`. Это позволит убедиться, что `HEAD` указывает на ветку, принимающую результаты слияния. При необходимости выполните команду `git checkout <принимающая-ветка>`, чтобы переключиться на принимающую ветку. Для примера выполним команду:
```
git checkout master
```

*Разрешение конфликтов*

При попытке объединить ветки, в которых изменена одна и та же часть того же файла, Git не сможет сделать выбор между версиями. В таком случае операция останавливается прямо перед созданием коммита слияния, чтобы пользователь вручную разрешил конфликты.

Преимущество слияния в Git заключается в том, что разрешение конфликтов при слиянии проходит по привычной схеме «редактирование — индексирование — коммит». При обнаружении конфликта выполните команду `git status`, чтобы увидеть, какие файлы необходимо исправить. Так, если в обеих ветках изменена одна и та же часть файла `Git_Instruction.md`, вы увидите следующее:
```
On branch master
Unmerged paths:
(use "git add/rm ..." as appropriate to mark resolution)
both modified: Git_Instruction.md
```
Когда Git обнаруживает конфликт в ходе слияния, к затронутым файлам добавляются визуальные индикаторы по обе стороны проблемного содержимого: `<<<<<<<`, `=======` и `>>>>>>>`. Чтобы обнаружить конфликты, попробуйте поискать в проекте эти индикаторы.
```
here is some content not affected by the conflict
.<<<<<<< master
this is conflicted text from master
=======
this is conflicted text from test_2
.>>>>>>> test_2
```
Обычно содержимое перед отметкой `=======` относится к принимающей ветке, а все, что указано после нее, — к ветке, для которой выполняется слияние.

После обнаружения конфликтующих участков кода вы можете исправить их по своему усмотрению. Когда вы будете готовы завершить слияние, выполните команду `git add` для конфликтующего файла или файлов — так вы сообщите Git, что конфликт разрешен. Затем выполните обычную команду `git commit`, чтобы создать коммит слияния. Поскольку процесс ничем не отличается от фиксирования обычного снимка состояния, рядовому разработчику не составит труда разрешить конфликты при слиянии.

>Обратите внимание, что конфликты возможны только в процессе трехстороннего слияния и не могут возникать при ускоренном слиянии.

## 11. Удаление веток
Итак, вы создали ветку, чтобы работать в ней над какими-то изменениями. Затем вы слили свои изменения в исходную версию проекта.

Это значит, что вам больше не нужна ветка, в которой вы работали над изменениями. Удалить ее будет хорошим тоном: таким образом она не будет мешаться в вашем коде.
Команда удаления указанной ветки выглядит так:
```
git branch -d <название ветки>
```
Это безопасная операция, поскольку Git не позволит удалить ветку, если в ней есть неслитые изменения.

Давайте рассмотрим удаление ветки на примере:

Есть две ветки `master` и `test_2`, сейчас мы находимся на ветке `test_2` на что указывает значок **\(*)**:

```
>git branch
  master
* test_2
```
 Удалить ветку, в которой вы находитесь и которую просматриваете в данный момент, нельзя. Если мы попытаемся это сделать, то получим примерно такую ошибку:
 ```
 >git branch -d test_2
 error: Vannot delete branch 'test_2' checked out at ....
 ```

 Так что перед удалением локальной ветки обязательно переключитесь на другую, которую не собираетесь удалять. Переход делается при помощи команды `git checkout`. После перехода на другую ветку можем повторно запустить команду удаления.
 >Команда `git branch -d` работает не во всех случаях.

Если в ветке присутствуют несмерженные изменения или незапушенные коммиты, флаг -d не позволит удалить такую локальную ветку. Это связано с тем, что эти коммиты нигде более не отслеживаются, и Git защищает вас от случайной потери этих данных.

Если все же попытаться удалить такую ветку, Git выдаст ошибку:
```
> git branch -d test_2
error: The branch 'test_2' is not fully merged.
If you are sure you want to delete it, run 'git branch -D test_2'
```
Как предложено в тексте ошибки, вы должны воспользоваться флагом -D. Принудительное удаление указанной ветки, даже если в ней есть неслитые изменения, выглядит таким образом:
```
git branch -D <название ветки>
```
Эта команда используется, если вы хотите навсегда удалить все коммиты, связанные с определенным направлением разработки.

>![Внимание] Используйте данную команду с осторожностью: после её ввода у вас не будут просить подтверждение удаления. Прибегайте к ней только когда абсолютно уверены, что хотите удалить локальную ветку.
Если вы не объединили её с другой локальной веткой или не запушили изменения в удаленный репозиторий, вы рискуете потерять все произведённые изменения.

# Работа с удалёнными репозиториями

Для работы с удалёнными репозиториями, в первую очередь нам необходимо создать аккаунт в [Github](https://github.com), если вы еще ни разу не работали с Github и у вас нет аккаунта в Github. Во вторых нам необходимо создать локальный репозитории на нашем компьютере. Далее связываем удалённый репозитории с локальным.

Чтобы связать локальный и удалённые репозитории, при создании репозитории в Github, на первой страничке после создания репозитория, описаны три метода связать локальный и удалённый репозиторий:
1. Создать новый репозитории через терминал.
```
echo "# ueu11" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/(название вашего аккаунта)/(название вашего репозитория).git
git push -u origin main
```
2. Отправить существующий репозиторий через терминал.
```
git remote add origin https://github.com/(название вашего аккаунта)/(название вашего репозитория).git
git branch -M main
git push -u origin main
```
3. Инициализировать репозитории кодом из проекта Subversion, Mercurial или TFS.

Для нас достаточно первые два метода которые разберем ниже.

## 1. Создание нового репозитория
Для создания нового репозитория нужно проделать следующие шаги:
1. Создаем паку у себя на компьютере, который мы инициализируем как новый репозиторий.
2. Создаем файл README.md с помощью команды:
```
echo "# (название вашего репозитория на англ)" >> README.md
```
3. Инициализируем репозиторий:
```
git init
```
3. Добавляем файл README.md в репозиторий для отслеживания:
```
git add README.md
```
4. Делаем первый коммит:
```
git commit -m "first commit"
```
5. Переименовываем название ветки что бы и в локальной и в удаленном репозитории они были одинаковы:
```
git branch -M main
```
6. Соединяем локальный и удалённый репозиторий:
```
git remote add origin https://github.com/(название вашего аккаунта)/(название вашего репозитория).git
```
7. Отправляем все изменения которые мы сделали в локальном репозитории в удалённый:
```
git push -u origin main
```

Добавить удалённый репозиторий к проекту:
```
git remote add <имя для репозитория> <url> - адрес репозитория в сети
```
## 2. Подключить существующий репозиторий
Если у вас уже есть локальный репозитории, то первые четыре шага с предыдущего раздела пропускаем и делаем следующие шаги:
1. Переименовываем название ветки что бы и в локальной и в удаленном репозитории они были одинаковы:
```
git branch -M main
```
2. Соединяем локальный и удалённый репозиторий:
```
git remote add origin https://github.com/(название вашего аккаунта)/(название вашего репозитория).git
```
3. Отправляем все изменения которые мы сделали в локальном репозитории в удалённый:
```
git push -u origin main
```
## 3. Основные команды для работы с удалёным репозиторием

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

**git fetch**

Команда `git fetch` связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

Для получения данных из удалённых проектов следует выполнить:
```
git fetch [remote-name]
```
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

**git pull**

Команда `git pull` работает как комбинация команд `git fetch` и `git merge`, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

**git push**
Команда `git push` используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: `git push <remote-name> <branch-name>`. Чтобы отправить вашу ветку master/main на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:
```
git push origin master
```
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись и, если никто другой с тех пор не выполнял команду `push`. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду `push`, а после него выполнить команду `push` попытаетесь вы, то ваш `push` точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить `push`.

**git remote**

Команда `git remote` служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например `«origin»`, так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и `git remote` поможет добавлять, изменять и удалять их.

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду `git remote`. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите, как минимум `origin` — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:
```
$ git remote
origin
```
Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:
```
$ git remote -v
origin  https://github.com/schacon/ticgit (fetch)
origin  https://github.com/schacon/ticgit (push)
```
Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:
```
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
```

## 4. Работа над проектом другого пользователя
В Github можно работать над проектом другого пользователя. Для этого нам необходимо найти нужный нам репозитории через поиск. Далее нажать на кнопку  надписью `Fork`:
![Чтобы сделать форк](Fork.jpg) 
После чего откроется следующее окно где мы сможем изменить название репозитории или же оставить как есть, можем добавить какое-то описание и нажимаем на Create fork:

Проект другого пользователя полностью скопируется на наш репозитории и далее мы сможем вводить любые изменения и дополнения:
![Страница добавления Fork репозитория](create_new_fork.jpg)

Чтобы производить изменения нам необходимо клонировать удалённый репозитории в наш локальный репозитории. Клонирование репозитория осуществляется командой `git clone <url>`. Например, если вы хотите клонировать репозитории SCV_Git_2412, вы можете сделать это следующим образом:
```
git clone https://github.com/RustamAY/SCV_Git_2412.git
```
Эта команда создаёт каталог SCV_Git_2412, инициализирует в нём подкаталог .git, скачивает все данные для этого репозитория и извлекает рабочую копию последней версии. Если вы перейдёте в только что созданный каталог SCV_Git_2412, то увидите в нём файлы проекта, готовые для работы или использования. Для того, чтобы клонировать репозиторий в каталог с именем, отличающимся от SCV_Git_2412, необходимо указать желаемое имя, как параметр командной строки:
```
git clone https://github.com/RustamAY/SCV_Git_2412.git MyWork
```
Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог будет назван MyWork.

После всех этих действии вы добавили свои изменения в проект и вам необходимо отправить их в удалённый репозитории, для этого вам понадобится команда `git push` (о данной команды говорилось в разделе 3).

Если мы сделали изменения в отдельной ветке и этой ветки нет в удалённом репозитории, то когда мы используем команду `git push` у нас появится такое сообщение:
```
$ git push
fatal: The current branch git_instruction has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin git_instruction

To have this happen automatically for branches without a tracking
upstream, see 'push.autoSetupRemote' in 'git help config'.
```
Git нам подсказывает что в удалённом репозитории нет такой ветки и предлагет отправить текущую ветку в удалённый репозиторий, использовав команду:
```
git push --set-upstream origin git_instruction
```

Проверим Github, когда мы зайдем на наш репозитории или обновим страницу в репозитории (если мы не закрывали Github) то у нас появится пот такая кнопочка:
![Кнопка для отправки ПР](pr_button.jpg)
нажимаем на кнопку `Compare & pull request` и нам откроется следующее окно:
![Окно для написания комментария к ПР](pr_create.jpg)
В этом окне можем написать наши комментарии и нажать `Create pull request` и изменения которые мы сделали отправятся на рассмотрение владельцу проекта.

_____________________________________________________________
Использованные ресурсы:
1. [Справочник по Markdown от Microsoft:](https://learn.microsoft.com/ru-ru/contribute/markdown-reference).
2. [Книга по Git на официальном сайте](https://git-scm.com/book/ru/v2).